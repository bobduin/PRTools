<html><body bgcolor="#3030a0"><table bgcolor="#eeeeee"  border="5" cellspacing="0" cellpadding="5" width="700" white-space="normal"  align="center"><tr><td><table border="0" cellspacing="0" cellpadding="3" width="100%" align="center"><tr><td><a href="../prtools.html">PRTools Contents</a></td><td><p align="right"><a href="http://37steps.com/prtools/" target="_top">PRTools User Guide</a></p></td></tr></table><head><title>prmapping</title></head>
<p align="center"><font face="Courier" size=5><strong>PRMAPPING</strong></font></p>
<h3> Mapping class constructor
</h3>
<p>
</p>
<p><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;W = PRMAPPING(MAPPING_FILE,MAPPING_TYPE,DATA,LABELS,SIZE_IN,SIZE_OUT)</font><br>
<font face="Courier" size="2">&nbsp;&nbsp;&nbsp;U = PRMAPPING(MAPPING_FILE,'untrained',PARS)</font><br>
<font face="Courier" size="2">&nbsp;&nbsp;&nbsp;W = PRMAPPING(MAPPING_FILE,'combiner',PARS)</font><br>
</p><h3> Description</h3><p><font face="Courier" size="2"> A </font>mapping/classifier object<font face="Courier" size="2"> W </font>is constructed. It points to the command&nbsp;<font face="Courier" size="2"> MAPPING_FILE </font>that is able to execute the mapping. It may be used to map a&nbsp; dataset<font face="Courier" size="2"> A </font>on another dataset<font face="Courier" size="2"> B </font>by<font face="Courier" size="2"> B = PRMAP(A,W) </font>or by training a mapping&nbsp; using an untrained mapping<font face="Courier" size="2"> U </font>and a dataset<font face="Courier" size="2"> A: W = PRMAP(A,U) </font>or by modifying,&nbsp; (or combining) a mapping<font face="Courier" size="2"> W </font>with another mapping<font face="Courier" size="2"> V: W_NEW = PRMAP(V,W); </font> These operations may also be written as<font face="Courier" size="2"> B = A*W, W = A*U </font>or<font face="Courier" size="2"> W_NEW = V*W</font>.</p>
<p> As a general rule for the case<font face="Courier" size="2"> A </font>is a cell array<font face="Courier" size="2">, B = A*W </font>is executed&nbsp; for all elements in<font face="Courier" size="2"> A</font>, returning a cell array<font face="Courier" size="2"> B: </font>B{i}<font face="Courier" size="2"> = </font>A{i}*W. An&nbsp; exeception is the mapping type 'fixed_cell', see below.</p>
<p> As PRTools contains many predifined mappings there is no need for the&nbsp; starting user to define his own mappings. Advanced users may inspect&nbsp; simple examples like<font face="Courier" size="2"> SIGM </font>or<font face="Courier" size="2"> SUBSC </font>to see how they are constructed.</p>
<p></p><p><table cellspacing="0" cellpadding="3" width="100%" align="center" border="0"<tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;MAPPING_FILE</font></td><td valign="baseline"><font face="Courier" size="2">        </font>name of the routine used for defining, training or&nbsp; executing the mapping. Such a routine (e.g.&nbsp; 'mapfile'), typically a classifier or a data mapping,&nbsp; should generate a mapping<font face="Courier" size="2"> W </font>or<font face="Courier" size="2"> U</font>, and should also be&nbsp; able to accept and execute the following types of calls,&nbsp; generated by PRTools depending on the value of&nbsp;<font face="Courier" size="2"> MAPPING_TYPE: </font><ul><li><font face="Courier" size="2"> MAPPING_TYPE = </font>'untrained': An untrained mapping<font face="Courier" size="2"> U </font>is trained by&nbsp;<font face="Courier" size="2"> W = </font>mapfile<font face="Courier" size="2">(A,U) </font>in which<font face="Courier" size="2"> U </font>is typically defined by&nbsp;<font face="Courier" size="2"> U = </font>mapfile<font face="Courier" size="2">([],PARS{:}) </font>or by just<font face="Courier" size="2"> U = </font>mapfile. PRTools&nbsp; generates<font face="Courier" size="2"> W = </font>mapfile<font face="Courier" size="2">(A,U) </font>if the user supplies&nbsp;<font face="Courier" size="2"> V = A*U</font>.<li><font face="Courier" size="2"> MAPPING_TYPE = </font>'trained':<font face="Courier" size="2"> A </font>trained mapping<font face="Courier" size="2"> W </font>can be applied to a&nbsp; dataset<font face="Courier" size="2"> D </font>by<font face="Courier" size="2"> D = </font>mapfile<font face="Courier" size="2">(B,W)</font>, resulting in a&nbsp; dataset<font face="Courier" size="2"> D</font>. PRTools generates this call if the user&nbsp; supplies<font face="Courier" size="2"> D = B*W</font>. If<font face="Courier" size="2"> W </font>is the result of training an&nbsp; untrained mapping<font face="Courier" size="2"> U </font>by a dataset<font face="Courier" size="2"> A </font>it holds that&nbsp;<font face="Courier" size="2"> D = B*(A*U)</font>.<li><font face="Courier" size="2"> MAPPING_TYPE = </font>'combiner':<font face="Courier" size="2"> A </font>combiner mapping<font face="Courier" size="2"> W </font>is able to modify or&nbsp; combine a set of mappings<font face="Courier" size="2"> V</font>. PRTools calls<font face="Courier" size="2"> V2 = V1*W </font> as<font face="Courier" size="2"> V2 = </font>mapfile<font face="Courier" size="2">(V1,PARS{:})</font>. If<font face="Courier" size="2"> W </font>would not have been&nbsp; a combiner then<font face="Courier" size="2"> V2 = V1*W </font>would have been stored as a&nbsp; sequential mapping. See<font face="Courier" size="2"> SEQUENTIAL </font><li><font face="Courier" size="2"> MAPPING_TYPE = </font>'fixed':<font face="Courier" size="2"> D = A*W </font>is executed by<font face="Courier" size="2"> D = </font>mapfile<font face="Courier" size="2">(A,PARS{:})</font>.&nbsp; In practice there is not much of a difference between&nbsp; a trained and a fixed mapping. The first is found from&nbsp; data, the latter is defined directly by its parameters<li><font face="Courier" size="2"> MAPPING_TYPE = </font>'fixed_cell': Like a fixed mapping.<font face="Courier" size="2"> D = A*W </font>is executed&nbsp; by<font face="Courier" size="2"> D = </font>mapfile<font face="Courier" size="2">(A,PARS{:})</font>. However, in this case<font face="Courier" size="2"> A </font>can&nbsp; be a cell array. It thereby overrides the rule that a&nbsp; cellarray applied to a mapping is executed element by&nbsp; element.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;MAPPING_TYPE</font></td><td valign="baseline"><font face="Courier" size="2">        </font>String defining the type of mapping:&nbsp; 'untrained', 'trained', "combiner' or 'fixed', see above.&nbsp; Default is 'untrained'.<font face="Courier" size="2"> PRMAPPING(MAPPING_FILE,DATA) </font>is&nbsp; equivalent to<font face="Courier" size="2"> PRMAPPING(MAPPING_FILE</font>,'untrained'<font face="Courier" size="2">,DATA) </font></td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;DATA</font></td><td valign="baseline"><font face="Courier" size="2">                </font>Data, structure or cell array necessary for defining the&nbsp; mapping, e.g. the weights of a neural network.<font face="Courier" size="2"> DATA </font>is&nbsp; just used in the<font face="Courier" size="2"> MAPPING_FILE </font>for executing the mapping.&nbsp; For fixed and untrained mappings<font face="Courier" size="2"> DATA </font>can only be a&nbsp; cell array.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;LABELS</font></td><td valign="baseline"><font face="Courier" size="2">              </font>Array with labels to be used as feature labels for the&nbsp; dataset resulting by executing the mapping. So at least&nbsp; as many labels as defined by<font face="Courier" size="2"> SIZE_OUT </font>has to be supplied.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;SIZE_IN</font></td><td valign="baseline"><font face="Courier" size="2">             </font>Input dimensionality or size vector describing its shape,&nbsp; e.g. in case the input space is derived from an image.&nbsp; For a classifier<font face="Courier" size="2"> SIZE_IN </font>is the feature size.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;SIZE_OUT</font></td><td valign="baseline"><font face="Courier" size="2">            </font>Output dimensionality or size vector describing its&nbsp; shape, e.g. in case the output space should represent an&nbsp; image. For a classifier<font face="Courier" size="2"> SIZE_OUT </font>is the number of&nbsp; classes. Default is the number of labels in<font face="Courier" size="2"> LABELS</font>.&nbsp;<font face="Courier" size="2"> SIZE_IN </font>and<font face="Courier" size="2"> SIZE_OUT </font>are just used for error checking.&nbsp; If<font face="Courier" size="2"> SIZE_IN </font>is not supplied they are both set to<font face="Courier" size="2"> 0 </font>and&nbsp; checking is skipped.</td></tr></td></tr></table>
</p>
<p> Other parameter fields may be set to define the mapping further by</p>
<p><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;W = PRMAPPING(MAPPING_FILE, MAPPING_TYPE, DATA, LABELS, ...</font><br>
<font face="Courier" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'field1',V1,'field2',V2, ...)</font><br>
&nbsp; or by</p>
<p><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;W = PRMAPPING(MAPPING_FILE, MAPPING_TYPE, DATA, LABELS, ...</font><br>
<font face="Courier" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIZE_IN, SIZE_OUT,'field1',V1,'field2',V2, ...)</font><br>
</p>
<p> The following fields are possible (if not set defaults are supplied)<br></p>
<p></p><p><table cellspacing="0" cellpadding="3" width="100%" align="center" border="0"<tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;SCALE</font></td><td valign="baseline"><font face="Courier" size="2">                </font>Output multiplication factor. If<font face="Courier" size="2"> SCALE </font>is a scalar all&nbsp; multiplied by it.<font face="Courier" size="2"> SCALE </font>may also be a vector with size&nbsp; as defined by<font face="Courier" size="2"> SIZE_OUT </font>to set separate scalings for each&nbsp; output.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;OUT_CONV</font></td><td valign="baseline"><font face="Courier" size="2">             0,1,2,3 </font>for defining the desired output conversion:&nbsp;<font face="Courier" size="2"> 0 -</font> no(default)<font face="Courier" size="2">, 1: SIGM, 2: NORMM </font>or<font face="Courier" size="2"> 3: SIGM </font>and<font face="Courier" size="2"> NORMM</font>.&nbsp; These values are set by cnormc in case of<font face="Courier" size="2"> 2-</font>class&nbsp; discriminants<font face="Courier" size="2"> (OUTCONV = 1) </font>and by<font face="Courier" size="2"> CLASSC </font><font face="Courier" size="2"> (OUT_CONV = OUT_CONV+2) </font>to convert densities and&nbsp; sigmoidal outputs to normalised posterior probabilities.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;COST</font></td><td valign="baseline"><font face="Courier" size="2">                 </font>Classification costs in case the mapping defines a&nbsp; classifier. See<font face="Courier" size="2"> SETCOST</font>.</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;NAME</font></td><td valign="baseline"><font face="Courier" size="2">                 </font>String with mapping name</td></tr><tr> <td width="120" valign="baseline"><font face="Courier" size="2">&nbsp;USER</font></td><td valign="baseline"><font face="Courier" size="2">                 </font>User definable variable</td></tr></td></tr></table>
</p>
<p> All parameters are stored in fields corresponding to the above names.&nbsp; Parameter fields of a given mapping may also be changed by<br></p>
<p><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;W = SET(W,'field1',V1,'field2',V2, ...)</font><br>
</p>
<p> They may also be set by the routines<font face="Courier" size="2"> SETMAPPING_FILE, SETMAPPING_TYPE</font>,&nbsp;<font face="Courier" size="2"> SETDATA, SETLABELS, SETSIZE_IN, SETSIZE_OUT, SETSIZE, SETSCALE, SETOUT_CONV</font>,&nbsp;<font face="Courier" size="2"> SETCOST, SETNAME </font>and<font face="Courier" size="2"> SETUSER</font>. Fields may be retrieved by</p>
<p><font face="Courier" size="2">&nbsp;&nbsp;&nbsp;VARARGOUT = GET(W,'field1','field2', ...)</font><br>
</p>
<p> or by the routines<font face="Courier" size="2"> GETMAPPING_FILE, GETMAPPING_TYPE, GETDATA, GETSIZE_IN</font>,&nbsp;<font face="Courier" size="2"> GETSIZE_OUT, GETSCALE, GETOUTCONV, GETCOST, GETNAME </font>and<font face="Courier" size="2"> GETUSER</font>.</p><h3> See also</h3><p>
<font face="Courier" size="3"><a href="../prtools/datasets.html">datasets</a>, <a href="../prtools/mappings.html">mappings</a>, <a href="../prtools/sequential.html">sequential</a>, </font></p><table border="0" cellspacing="0" cellpadding="3" width="100%" align="center"><tr><td><a href="../prtools.html">PRTools Contents</a></td><td><p align="right"><a href="http://37steps.com/prtools/" target="_top">PRTools User Guide</a></p></td></tr></table><table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td align="center"><em>This file has been automatically generated. If badly readable, use the help-command in Matlab.</em></td></tr></table></table></body></html>